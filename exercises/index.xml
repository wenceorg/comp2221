<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Exercises on COMP2221 – Functional Programming</title><link>https://teaching.wence.uk/comp2221/exercises/</link><description>Recent content in Exercises on COMP2221 – Functional Programming</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://teaching.wence.uk/comp2221/exercises/index.xml" rel="self" type="application/rss+xml"/><item><title>Hello, World!</title><link>https://teaching.wence.uk/comp2221/exercises/exercise1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://teaching.wence.uk/comp2221/exercises/exercise1/</guid><description>Beginnings # GHC provides either a compiler, with which we can compile a Haskell program into an executable, and an interpreter with a read-eval-print-loop. Initially, we&amp;rsquo;ll start off using the interpreter. It can be invoked with ghci, so at a terminal prompt run
$ ghci When I show commands in the terminal, I will use a $ to indicate the prompt (which you should not type), followed by the command to type.</description></item><item><title>Types and lists</title><link>https://teaching.wence.uk/comp2221/exercises/exercise2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://teaching.wence.uk/comp2221/exercises/exercise2/</guid><description>Thinking about types # You&amp;rsquo;ve probably noticed by now that GHC will complain if you write some code where the types don&amp;rsquo;t match. To do this, it uses type inference to determine the valid types of any functions you write, and checks that everything works. For example, suppose I have a function
allTrue :: [Bool] -&amp;gt; Bool allTrue [] = True allTrue (x:xs) = x &amp;amp;&amp;amp; allTrue xs which checks if every entry of a list of Bools is True.</description></item><item><title>List manipulation and sorting</title><link>https://teaching.wence.uk/comp2221/exercises/exercise3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://teaching.wence.uk/comp2221/exercises/exercise3/</guid><description>More list manipulation # We&amp;rsquo;ll start off doing a bit more list manipulation, looking at some list comprehensions and pattern matching. Then we&amp;rsquo;ll implement merge sort.
List comprehensions &amp;amp; pattern matching # For this section, the template code is code/lists-exercise3.hs.
Let&amp;rsquo;s first look at some pattern matching, and combination with guard expressions.
Exercise Write a function compress :: Eq a =&amp;gt; [a] -&amp;gt; [a] that eliminates consecutive duplicate elements of a list, but otherwise leaves the order unchanged.</description></item><item><title>Lazy evaluation and infinite datastructures</title><link>https://teaching.wence.uk/comp2221/exercises/exercise4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://teaching.wence.uk/comp2221/exercises/exercise4/</guid><description>Lazy data, infinite data # Haskell does not evaluate expressions eagerly, but instead does so lazily. This opens the door to writing very succint programs that operator on infinite datastructures. We can just write them without needing to have a cut-off and then pick out the pieces we want.
For some more examples, on top of the ones we have here, there&amp;rsquo;s a nice Computerphile video on infinite datastructures, featuring Graham Hutton.</description></item><item><title>Folds and function composition</title><link>https://teaching.wence.uk/comp2221/exercises/exercise5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://teaching.wence.uk/comp2221/exercises/exercise5/</guid><description>Higher order functions # foldl and foldr # Many functions that apply to lists can be written, as we saw in lectures, in the form:
f [] = v f (x:xs) = x `op` f xs which turns the empty list into some initial value (here v) and all other lists to the result of apply a specified binary operator op to the head of the list and the result of recursion on the tail.</description></item><item><title>Some classic data structures</title><link>https://teaching.wence.uk/comp2221/exercises/exercise6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://teaching.wence.uk/comp2221/exercises/exercise6/</guid><description>Manipulating data types # A binary tree # In lectures we saw (repeatedly) a binary tree with values at nodes and empty leaves. This time, we&amp;rsquo;re going to make a tree that holds values at nodes and leaves, and then do some manipulation of it.
Our data type is
data Tree a = Leaf a | Node (Tree a) a (Tree a) deriving (Eq, Show) The template code/trees-exercise6.hs also defines some helper functions to construct trees of various kinds</description></item><item><title>Another mini expression evaluator</title><link>https://teaching.wence.uk/comp2221/exercises/exercise7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://teaching.wence.uk/comp2221/exercises/exercise7/</guid><description>Checking for satisfiability # In this exercise, we&amp;rsquo;re going to develop a very simple SAT solver. To do so, we&amp;rsquo;ll first build data structures to represent boolean expressions. An expression is SAT if there is a consistent assignment of boolean values to the variables in the expression such that it evaluates to True.
The point of this exercise is not to develop a good SAT solver. We are doing the naivest possible thing.</description></item></channel></rss>