<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Higher order functions #  foldl and foldr #  Many functions that apply to lists can be written, as we saw in lectures, in the form:
f [] = v f (x:xs) = x `op` f xs which turns the empty list into some initial value (here v) and all other lists to the result of apply a specified binary operator op to the head of the list and the result of recursion on the tail."><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="Folds and function composition"><meta property="og:description" content="Higher order functions #  foldl and foldr #  Many functions that apply to lists can be written, as we saw in lectures, in the form:
f [] = v f (x:xs) = x `op` f xs which turns the empty list into some initial value (here v) and all other lists to the result of apply a specified binary operator op to the head of the list and the result of recursion on the tail."><meta property="og:type" content="article"><meta property="og:url" content="https://teaching.wence.uk/comp2221/exercises/exercise5/"><meta property="article:section" content="exercises"><meta property="article:modified_time" content="2022-04-07T18:06:14+01:00"><title>Folds and function composition | COMP2221 – Functional Programming</title><link rel=manifest href=/comp2221/manifest.json><link rel=icon href=/comp2221/favicon.png type=image/x-icon><link rel=stylesheet href=/comp2221/book.min.b85762cbec3aa7dfc1fa14ce1d900668d26349753560425c37dac8f9e08407d6.css integrity="sha256-uFdiy+w6p9/B+hTOHZAGaNJjSXU1YEJcN9rI+eCEB9Y="><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})})</script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><nav><div class=book-brand><img class=book-center src=/comp2221/logo.svg alt=Logo><h2><a href=/comp2221>COMP2221 – Functional Programming</a></h2></div><ul><li><a href=/comp2221/setup/>Setup</a><ul></ul></li><li><a href=/comp2221/slides/>Slides & commentary</a></li><li><a href=/comp2221/exercises/>Exercises</a><ul><li><a href=/comp2221/exercises/exercise1/>Hello, World!</a></li><li><a href=/comp2221/exercises/exercise2/>Types and lists</a></li><li><a href=/comp2221/exercises/exercise3/>List manipulation and sorting</a></li><li><a href=/comp2221/exercises/exercise4/>Lazy evaluation and infinite datastructures</a></li><li><a href=/comp2221/exercises/exercise5/ class=active>Folds and function composition</a></li><li><a href=/comp2221/exercises/exercise6/>Some classic data structures</a></li><li><a href=/comp2221/exercises/exercise7/>Another mini expression evaluator</a></li></ul></li><li><span>Past editions</span><ul><li><span>2020/21</span><ul><li><a href=/comp2221/past-editions/2020-21/lectures/>Annotated slides</a></li></ul></li></ul></li></ul></nav><script>(function(){var a=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(b){localStorage.setItem("menu.scrollTop",a.scrollTop)}),a.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/comp2221/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Folds and function composition</strong>
<label for=toc-control><img src=/comp2221/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#higher-order-functions>Higher order functions</a><ul><li><a href=#foldl-and-foldr><code>foldl</code> and <code>foldr</code></a><ul><li><a href=#library-functions-with-folds>Library functions with folds</a></li><li><a href=#higher-order-functions-with-folds>Higher order functions with folds</a></li><li><a href=#fold-map-fusion>Fold-map fusion</a></li></ul></li></ul></li></ul></nav></aside></header><article class=markdown><blockquote class="book-hint warning"><span>This course page was updated until March 2022 when I left Durham University.
For future updates, please visit
the <a href=https://comp2221.github.io/fp-website/>new version
of the course pages</a>.</span></blockquote><h1 id=higher-order-functions>Higher order functions
<a class=anchor href=#higher-order-functions>#</a></h1><h2 id=foldl-and-foldr><code>foldl</code> and <code>foldr</code>
<a class=anchor href=#foldl-and-foldr>#</a></h2><p>Many functions that apply to lists can be written, as we saw in
lectures, in the form:</p><div class=highlight><pre style=color:#272822;background-color:#fafafa><code class=language-hs data-lang=hs><span style=color:#75af00>f</span> <span style=color:#00a8c8>[]</span> <span style=color:#f92672>=</span> <span style=color:#111>v</span>
<span style=color:#75af00>f</span> <span style=color:#111>(</span><span style=color:#111>x</span><span style=color:#00a8c8>:</span><span style=color:#111>xs</span><span style=color:#111>)</span> <span style=color:#f92672>=</span> <span style=color:#111>x</span> <span style=color:#111>`</span><span style=color:#111>op</span><span style=color:#111>`</span> <span style=color:#111>f</span> <span style=color:#111>xs</span>
</code></pre></div><p>which turns the empty list into some initial value (here <code>v</code>) and all
other lists to the result of apply a specified binary operator <code>op</code> to
the head of the list and the result of recursion on the tail.</p><p>For example</p><div class=highlight><pre style=color:#272822;background-color:#fafafa><code class=language-hs data-lang=hs><span style=color:#75af00>sum</span> <span style=color:#f92672>::</span> <span style=color:#00a8c8>Num</span> <span style=color:#111>a</span> <span style=color:#f92672>=&gt;</span> <span style=color:#111>[</span><span style=color:#111>a</span><span style=color:#111>]</span> <span style=color:#f92672>-&gt;</span> <span style=color:#111>a</span>
<span style=color:#75af00>sum</span> <span style=color:#00a8c8>[]</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
<span style=color:#75af00>sum</span> <span style=color:#111>(</span><span style=color:#111>x</span><span style=color:#00a8c8>:</span><span style=color:#111>xs</span><span style=color:#111>)</span> <span style=color:#f92672>=</span> <span style=color:#111>x</span> <span style=color:#f92672>+</span> <span style=color:#111>sum</span> <span style=color:#111>xs</span>

<span style=color:#75af00>or</span> <span style=color:#f92672>::</span> <span style=color:#111>[</span><span style=color:#00a8c8>Bool</span><span style=color:#111>]</span> <span style=color:#f92672>-&gt;</span> <span style=color:#00a8c8>Bool</span>
<span style=color:#75af00>or</span> <span style=color:#00a8c8>[]</span> <span style=color:#f92672>=</span> <span style=color:#00a8c8>False</span>
<span style=color:#75af00>or</span> <span style=color:#111>(</span><span style=color:#111>x</span><span style=color:#00a8c8>:</span><span style=color:#111>xs</span><span style=color:#111>)</span> <span style=color:#f92672>=</span> <span style=color:#111>x</span> <span style=color:#f92672>||</span> <span style=color:#111>or</span> <span style=color:#111>xs</span>
</code></pre></div><p>We saw that this linear recursive pattern was captured in the higher
order function <code>foldr</code> (&ldquo;fold right&rdquo;). It is so named because
untangling the recursion, we see that the operator is applied in a
right-associative manner.</p><div class=highlight><pre style=color:#272822;background-color:#fafafa><code class=language-hs data-lang=hs><span style=color:#75af00>foldr</span> <span style=color:#f92672>::</span> <span style=color:#111>(</span><span style=color:#111>a</span> <span style=color:#f92672>-&gt;</span> <span style=color:#111>b</span> <span style=color:#f92672>-&gt;</span> <span style=color:#111>b</span><span style=color:#111>)</span> <span style=color:#f92672>-&gt;</span> <span style=color:#111>b</span> <span style=color:#f92672>-&gt;</span> <span style=color:#111>[</span><span style=color:#111>a</span><span style=color:#111>]</span> <span style=color:#f92672>-&gt;</span> <span style=color:#111>b</span>
</code></pre></div><p>With which we have</p><div class=highlight><pre style=color:#272822;background-color:#fafafa><code class=language-hs data-lang=hs><span style=color:#75af00>sum</span> <span style=color:#f92672>::</span> <span style=color:#00a8c8>Num</span> <span style=color:#111>a</span> <span style=color:#f92672>=&gt;</span> <span style=color:#111>[</span><span style=color:#111>a</span><span style=color:#111>]</span> <span style=color:#f92672>-&gt;</span> <span style=color:#111>a</span>
<span style=color:#75af00>sum</span> <span style=color:#f92672>=</span> <span style=color:#111>foldr</span> <span style=color:#111>(</span><span style=color:#f92672>+</span><span style=color:#111>)</span> <span style=color:#ae81ff>0</span>

<span style=color:#75af00>or</span> <span style=color:#f92672>::</span> <span style=color:#111>[</span><span style=color:#00a8c8>Bool</span><span style=color:#111>]</span> <span style=color:#f92672>-&gt;</span> <span style=color:#00a8c8>Bool</span>
<span style=color:#75af00>or</span> <span style=color:#f92672>=</span> <span style=color:#111>foldr</span> <span style=color:#111>(</span><span style=color:#f92672>||</span><span style=color:#111>)</span> <span style=color:#00a8c8>False</span>
</code></pre></div><p>We can think of <code>foldr</code> non-recursively as replacing the &ldquo;cons&rdquo;
operator <code>(:)</code> with the provided binary function, and the empty list
with the starting value. For example</p><div class=highlight><pre style=color:#272822;background-color:#fafafa><code class=language-hs data-lang=hs><span style=color:#75af00>foldr</span> <span style=color:#111>(</span><span style=color:#f92672>+</span><span style=color:#111>)</span> <span style=color:#ae81ff>0</span> <span style=color:#111>[</span><span style=color:#ae81ff>1</span><span style=color:#111>,</span> <span style=color:#ae81ff>2</span><span style=color:#111>,</span> <span style=color:#ae81ff>3</span><span style=color:#111>,</span> <span style=color:#ae81ff>4</span><span style=color:#111>]</span>
<span style=color:#f92672>==</span> <span style=color:#75715e>-- expanding the sugar for the list</span>
<span style=color:#75af00>foldr</span> <span style=color:#111>(</span><span style=color:#f92672>+</span><span style=color:#111>)</span> <span style=color:#ae81ff>0</span> <span style=color:#111>(</span><span style=color:#ae81ff>1</span> <span style=color:#00a8c8>:</span> <span style=color:#111>(</span><span style=color:#ae81ff>2</span> <span style=color:#00a8c8>:</span> <span style=color:#111>(</span><span style=color:#ae81ff>3</span> <span style=color:#00a8c8>:</span> <span style=color:#111>(</span><span style=color:#ae81ff>4</span> <span style=color:#00a8c8>:</span> <span style=color:#00a8c8>[]</span><span style=color:#111>))))</span>
<span style=color:#f92672>==</span> <span style=color:#75715e>-- replacing : with + and [] with 0</span>
<span style=color:#111>(</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>+</span> <span style=color:#111>(</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> <span style=color:#111>(</span><span style=color:#ae81ff>3</span> <span style=color:#f92672>+</span> <span style=color:#111>(</span><span style=color:#ae81ff>4</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>0</span><span style=color:#111>))))</span>
<span style=color:#f92672>==</span>
<span style=color:#ae81ff>10</span>
</code></pre></div><p>There is also a similar function <code>foldl</code> (&ldquo;fold left&rdquo;)</p><div class=highlight><pre style=color:#272822;background-color:#fafafa><code class=language-hs data-lang=hs><span style=color:#75af00>foldl</span> <span style=color:#f92672>::</span> <span style=color:#111>(</span><span style=color:#111>b</span> <span style=color:#f92672>-&gt;</span> <span style=color:#111>a</span> <span style=color:#f92672>-&gt;</span> <span style=color:#111>b</span><span style=color:#111>)</span> <span style=color:#f92672>-&gt;</span> <span style=color:#111>b</span> <span style=color:#f92672>-&gt;</span> <span style=color:#111>[</span><span style=color:#111>a</span><span style=color:#111>]</span> <span style=color:#f92672>-&gt;</span> <span style=color:#111>b</span>
</code></pre></div><p>which folds from the end of the list, rather than the beginning</p><div class=highlight><pre style=color:#272822;background-color:#fafafa><code class=language-hs data-lang=hs><span style=color:#75af00>foldl</span> <span style=color:#111>(</span><span style=color:#f92672>+</span><span style=color:#111>)</span> <span style=color:#ae81ff>0</span> <span style=color:#111>[</span><span style=color:#ae81ff>1</span><span style=color:#111>,</span> <span style=color:#ae81ff>2</span><span style=color:#111>,</span> <span style=color:#ae81ff>3</span><span style=color:#111>,</span> <span style=color:#ae81ff>4</span><span style=color:#111>]</span>
<span style=color:#f92672>==</span> <span style=color:#75715e>-- expanding the sugar for the list</span>
<span style=color:#75af00>foldl</span> <span style=color:#111>(</span><span style=color:#f92672>+</span><span style=color:#111>)</span> <span style=color:#ae81ff>0</span> <span style=color:#111>(</span><span style=color:#ae81ff>1</span> <span style=color:#00a8c8>:</span> <span style=color:#111>(</span><span style=color:#ae81ff>2</span> <span style=color:#00a8c8>:</span> <span style=color:#111>(</span><span style=color:#ae81ff>3</span> <span style=color:#00a8c8>:</span> <span style=color:#111>(</span><span style=color:#ae81ff>4</span> <span style=color:#00a8c8>:</span> <span style=color:#00a8c8>[]</span><span style=color:#111>))))</span>
<span style=color:#f92672>==</span> <span style=color:#75715e>-- replacing : with + and [] with 0</span>
<span style=color:#111>((((</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span><span style=color:#111>)</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>3</span><span style=color:#111>)</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>4</span><span style=color:#111>)</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>0</span><span style=color:#111>)</span>
<span style=color:#f92672>==</span>
<span style=color:#ae81ff>10</span>
</code></pre></div><p>This matches a pattern where the operator associates to the left,
rather than the right:</p><div class=highlight><pre style=color:#272822;background-color:#fafafa><code class=language-hs data-lang=hs><span style=color:#75af00>f</span> <span style=color:#111>v</span> <span style=color:#00a8c8>[]</span> <span style=color:#f92672>=</span> <span style=color:#111>v</span>
<span style=color:#75af00>f</span> <span style=color:#111>v</span> <span style=color:#111>(</span><span style=color:#111>x</span><span style=color:#00a8c8>:</span><span style=color:#111>xs</span><span style=color:#111>)</span> <span style=color:#f92672>=</span> <span style=color:#111>f</span> <span style=color:#111>(</span><span style=color:#111>v</span> <span style=color:#111>`</span><span style=color:#111>op</span><span style=color:#111>`</span> <span style=color:#111>x</span><span style=color:#111>)</span> <span style=color:#111>xs</span>
</code></pre></div><p>Which maps the empty list to an accumulator value, and any other list
to the result of processing the tail using a new accumulator obtained
by appling <code>op</code> to the accumulator and the head of the list.</p><blockquote class=question><h3>Question</h3><span>If presented with an infinite list which you wish to process in this
manner, should you use <code>foldr</code> or <code>foldl</code>, or does it not matter?
Explain your reasoning.</span></blockquote><h3 id=library-functions-with-folds>Library functions with folds
<a class=anchor href=#library-functions-with-folds>#</a></h3><blockquote class=exercise><h3>Exercise</h3><span><p>Let&rsquo;s implement a few library functions on lists by using <code>foldr</code> and
<code>foldl</code> to check we understand what&rsquo;s going on.</p><p>The template file for this exercise is <a href=https://teaching.wence.uk/comp2221/code/folds-exercise5.hs><code>code/folds-exercise5.hs</code></a>.</p><p>In particular, we&rsquo;re going to try and implement</p><div class=highlight><pre style=color:#272822;background-color:#fafafa><code class=language-hs data-lang=hs><span style=color:#75715e>-- Length of a list</span>
<span style=color:#75af00>length&#39;</span> <span style=color:#f92672>::</span> <span style=color:#111>[</span><span style=color:#111>a</span><span style=color:#111>]</span> <span style=color:#f92672>-&gt;</span> <span style=color:#00a8c8>Int</span>
<span style=color:#75715e>-- Map a function over a list to produce a new one</span>
<span style=color:#75af00>map&#39;</span> <span style=color:#f92672>::</span> <span style=color:#111>(</span><span style=color:#111>a</span> <span style=color:#f92672>-&gt;</span> <span style=color:#111>b</span><span style=color:#111>)</span> <span style=color:#f92672>-&gt;</span> <span style=color:#111>[</span><span style=color:#111>a</span><span style=color:#111>]</span> <span style=color:#f92672>-&gt;</span> <span style=color:#111>[</span><span style=color:#111>b</span><span style=color:#111>]</span>
<span style=color:#75715e>-- Reverse a list</span>
<span style=color:#75af00>reverse&#39;</span> <span style=color:#f92672>::</span> <span style=color:#111>[</span><span style=color:#111>a</span><span style=color:#111>]</span> <span style=color:#f92672>-&gt;</span> <span style=color:#111>[</span><span style=color:#111>a</span><span style=color:#111>]</span>
<span style=color:#75715e>-- Check if all entries in a boolean list are true</span>
<span style=color:#75af00>and&#39;</span> <span style=color:#f92672>::</span> <span style=color:#111>[</span><span style=color:#00a8c8>Bool</span><span style=color:#111>]</span> <span style=color:#f92672>-&gt;</span> <span style=color:#00a8c8>Bool</span>
</code></pre></div><p>Using both <code>foldl</code> and <code>foldr</code>.</p></span></blockquote><h3 id=higher-order-functions-with-folds>Higher order functions with folds
<a class=anchor href=#higher-order-functions-with-folds>#</a></h3><p>Having done that, we&rsquo;ll do a few more, this time higher-order
functions (again, using the same template file).</p><blockquote class=exercise><h3>Exercise</h3><span><p>There are three here that are relatively straightforward, and then one
which is <em>much harder</em> (so don&rsquo;t worry if it eludes you!). Try and
implement these using composition of existing higher-order functions
that you already know about.</p><div class=highlight><pre style=color:#272822;background-color:#fafafa><code class=language-hs data-lang=hs><span style=color:#75715e>-- Every entry satisfies a predicate, all p [] = True</span>
<span style=color:#75af00>all&#39;</span> <span style=color:#f92672>::</span> <span style=color:#111>(</span><span style=color:#111>a</span> <span style=color:#f92672>-&gt;</span> <span style=color:#00a8c8>Bool</span><span style=color:#111>)</span> <span style=color:#f92672>-&gt;</span> <span style=color:#111>[</span><span style=color:#111>a</span><span style=color:#111>]</span> <span style=color:#f92672>-&gt;</span> <span style=color:#00a8c8>Bool</span>
<span style=color:#75715e>-- At least one entry satisfies a predicate, any p [] = False</span>
<span style=color:#75af00>any&#39;</span> <span style=color:#f92672>::</span> <span style=color:#111>(</span><span style=color:#111>a</span> <span style=color:#f92672>-&gt;</span> <span style=color:#00a8c8>Bool</span><span style=color:#111>)</span> <span style=color:#f92672>-&gt;</span> <span style=color:#111>[</span><span style=color:#111>a</span><span style=color:#111>]</span> <span style=color:#f92672>-&gt;</span> <span style=color:#00a8c8>Bool</span>
<span style=color:#75715e>-- Return elements from a list while they satisfy a predicate, and</span>
<span style=color:#75715e>-- stop as soon as the predicate is not satisfied</span>
<span style=color:#75af00>takeWhile&#39;</span> <span style=color:#f92672>::</span> <span style=color:#111>(</span><span style=color:#111>a</span> <span style=color:#f92672>-&gt;</span> <span style=color:#00a8c8>Bool</span><span style=color:#111>)</span> <span style=color:#f92672>-&gt;</span> <span style=color:#111>[</span><span style=color:#111>a</span><span style=color:#111>]</span> <span style=color:#f92672>-&gt;</span> <span style=color:#111>[</span><span style=color:#111>a</span><span style=color:#111>]</span>
<span style=color:#75715e>-- Remove elements from a list while they satisfy some predicate, and</span>
<span style=color:#75715e>-- then return the remainder. This one is MUCH HARDER.</span>
<span style=color:#75af00>dropWhile&#39;</span> <span style=color:#f92672>::</span> <span style=color:#111>(</span><span style=color:#111>a</span> <span style=color:#f92672>-&gt;</span> <span style=color:#00a8c8>Bool</span><span style=color:#111>)</span> <span style=color:#f92672>-&gt;</span> <span style=color:#111>[</span><span style=color:#111>a</span><span style=color:#111>]</span> <span style=color:#f92672>-&gt;</span> <span style=color:#111>[</span><span style=color:#111>a</span><span style=color:#111>]</span>
</code></pre></div></span></blockquote><h3 id=fold-map-fusion>Fold-map fusion
<a class=anchor href=#fold-map-fusion>#</a></h3><p>You might have, and I did, implement <code>all'</code> like this</p><div class=highlight><pre style=color:#272822;background-color:#fafafa><code class=language-hs data-lang=hs><span style=color:#75af00>all&#39;</span> <span style=color:#111>p</span> <span style=color:#111>xs</span> <span style=color:#f92672>=</span> <span style=color:#111>and</span> <span style=color:#111>(</span><span style=color:#111>map</span> <span style=color:#111>p</span><span style=color:#111>)</span> <span style=color:#111>xs</span>
<span style=color:#75715e>-- Or</span>
<span style=color:#75af00>all&#39;</span> <span style=color:#111>p</span> <span style=color:#f92672>=</span> <span style=color:#111>and</span> <span style=color:#f92672>.</span> <span style=color:#111>map</span> <span style=color:#111>p</span>
</code></pre></div><p>This is a nice solution, but it does traverse the list twice, once to
apply <code>p</code> to every element, and then to check if they are all <code>True</code>.
Fortunately, we can avoid this double traversal, using an example of
provably safe program transformations. The particular one we need is
<a href=https://academic.oup.com/comjnl/article/32/2/122/543545><em>fold-map fusion (see Equation
11)</em></a>.</p><blockquote class=exercise><h3>Exercise</h3><span><p>Try writing a function</p><div class=highlight><pre style=color:#272822;background-color:#fafafa><code class=language-hs data-lang=hs><span style=color:#75af00>allSingleFold</span> <span style=color:#f92672>::</span> <span style=color:#111>(</span><span style=color:#111>a</span> <span style=color:#f92672>-&gt;</span> <span style=color:#00a8c8>Bool</span><span style=color:#111>)</span> <span style=color:#f92672>-&gt;</span> <span style=color:#111>[</span><span style=color:#111>a</span><span style=color:#111>]</span> <span style=color:#f92672>-&gt;</span> <span style=color:#00a8c8>Bool</span>
<span style=color:#75af00>allSingleFold</span> <span style=color:#111>p</span> <span style=color:#111>xs</span> <span style=color:#f92672>=</span> <span style=color:#111>undefined</span>
</code></pre></div><p>which does the same thing as <code>all'</code> but with only one traversal over
the list using <code>foldr</code>.</p><p>Think about what the operator you want to apply at every stage is.</p><details><summary>Hint</summary><div class=markdown-inner><p>The paper linked above shows an <em>equation</em> for fold-map fusion, namely</p><div class=highlight><pre style=color:#272822;background-color:#fafafa><code class=language-hs data-lang=hs><span style=color:#75af00>foldr</span> <span style=color:#111>op</span> <span style=color:#111>z</span> <span style=color:#f92672>.</span> <span style=color:#111>map</span> <span style=color:#111>p</span> <span style=color:#f92672>==</span> <span style=color:#111>foldr</span> <span style=color:#111>newop</span> <span style=color:#111>z</span>
  <span style=color:#00a8c8>where</span> <span style=color:#111>x</span> <span style=color:#111>`</span><span style=color:#111>newop</span><span style=color:#111>`</span> <span style=color:#111>y</span> <span style=color:#f92672>=</span> <span style=color:#111>p</span> <span style=color:#111>x</span> <span style=color:#111>`</span><span style=color:#111>op</span><span style=color:#111>`</span> <span style=color:#111>y</span>
</code></pre></div><p>This is a nice property, because it means we can always switch between
one form and the other, so optimising compilers can exploit the
property.</p></div></details></span></blockquote><div class=markdown-inner><h2 id=solutions>Solutions</h2><p>I&rsquo;ve added some <a href=https://teaching.wence.uk/comp2221/code/exercises/exercise5-solutions.hs>commented solutions</a> to these exercises. If you
have queries about them please ask in the practical sessions or else
<a href=https://teaching.wence.uk/comp2221/#discussion-forum>get in touch</a>.</div></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/wenceorg/comp2221/commit/198deafeeeb2da156fc46b80a0adbfce2f39646c title="Last modified by Lawrence Mitchell | April 7, 2022" target=_blank rel=noopener><img src=/comp2221/svg/calendar.svg class=book-icon alt=Calendar>
<span>April 7, 2022</span></a></div><div><a class="flex align-center" href=https://github.com/wenceorg/comp2221/edit/main/site/content/exercises/exercise5.md target=_blank rel=noopener><img src=/comp2221/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div><div class="flex flex-wrap align-right"><p>© 2021&ndash; <a href=mailto:lawrence@wence.uk>Lawrence Mitchell</a> & <a href=https://www.dur.ac.uk/>Durham University</a>.</p><p><a rel=license href=http://creativecommons.org/licenses/by-sa/4.0/><img alt="Creative Commons License" style=border-width:0 src=/comp2221/cc-by-sa.svg></a>
This work is licensed under a <a rel=license href=http://creativecommons.org/licenses/by-sa/4.0/>Creative
Commons Attribution-ShareAlike 4.0 International License</a>.</p></div></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><nav id=TableOfContents><ul><li><a href=#higher-order-functions>Higher order functions</a><ul><li><a href=#foldl-and-foldr><code>foldl</code> and <code>foldr</code></a><ul><li><a href=#library-functions-with-folds>Library functions with folds</a></li><li><a href=#higher-order-functions-with-folds>Higher order functions with folds</a></li><li><a href=#fold-map-fusion>Fold-map fusion</a></li></ul></li></ul></li></ul></nav></aside></main></body></html>