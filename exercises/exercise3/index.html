<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="More list manipulation #  We&rsquo;ll start off doing a bit more list manipulation, looking at some list comprehensions and pattern matching. Then we&rsquo;ll implement merge sort.
List comprehensions & pattern matching #  For this section, the template code is code/lists-exercise3.hs.
Let&rsquo;s first look at some pattern matching, and combination with guard expressions.
Exercise  Write a function compress :: Eq a => [a] -> [a] that eliminates consecutive duplicate elements of a list, but otherwise leaves the order unchanged."><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="List manipulation and sorting"><meta property="og:description" content="More list manipulation #  We&rsquo;ll start off doing a bit more list manipulation, looking at some list comprehensions and pattern matching. Then we&rsquo;ll implement merge sort.
List comprehensions & pattern matching #  For this section, the template code is code/lists-exercise3.hs.
Let&rsquo;s first look at some pattern matching, and combination with guard expressions.
Exercise  Write a function compress :: Eq a => [a] -> [a] that eliminates consecutive duplicate elements of a list, but otherwise leaves the order unchanged."><meta property="og:type" content="article"><meta property="og:url" content="https://teaching.wence.uk/comp2221/exercises/exercise3/"><meta property="article:section" content="exercises"><meta property="article:modified_time" content="2022-04-07T18:06:14+01:00"><title>List manipulation and sorting | COMP2221 – Functional Programming</title><link rel=manifest href=/comp2221/manifest.json><link rel=icon href=/comp2221/favicon.png type=image/x-icon><link rel=stylesheet href=/comp2221/book.min.b85762cbec3aa7dfc1fa14ce1d900668d26349753560425c37dac8f9e08407d6.css integrity="sha256-uFdiy+w6p9/B+hTOHZAGaNJjSXU1YEJcN9rI+eCEB9Y="><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})})</script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><nav><div class=book-brand><img class=book-center src=/comp2221/logo.svg alt=Logo><h2><a href=/comp2221>COMP2221 – Functional Programming</a></h2></div><ul><li><a href=/comp2221/setup/>Setup</a><ul></ul></li><li><a href=/comp2221/slides/>Slides & commentary</a></li><li><a href=/comp2221/exercises/>Exercises</a><ul><li><a href=/comp2221/exercises/exercise1/>Hello, World!</a></li><li><a href=/comp2221/exercises/exercise2/>Types and lists</a></li><li><a href=/comp2221/exercises/exercise3/ class=active>List manipulation and sorting</a></li><li><a href=/comp2221/exercises/exercise4/>Lazy evaluation and infinite datastructures</a></li><li><a href=/comp2221/exercises/exercise5/>Folds and function composition</a></li><li><a href=/comp2221/exercises/exercise6/>Some classic data structures</a></li><li><a href=/comp2221/exercises/exercise7/>Another mini expression evaluator</a></li></ul></li><li><span>Past editions</span><ul><li><span>2020/21</span><ul><li><a href=/comp2221/past-editions/2020-21/lectures/>Annotated slides</a></li></ul></li></ul></li></ul></nav><script>(function(){var a=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(b){localStorage.setItem("menu.scrollTop",a.scrollTop)}),a.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/comp2221/svg/menu.svg class=book-icon alt=Menu></label>
<strong>List manipulation and sorting</strong>
<label for=toc-control><img src=/comp2221/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#more-list-manipulation>More list manipulation</a><ul><li><a href=#list-comprehensions--pattern-matching>List comprehensions & pattern matching</a><ul><li><a href=#more-than-one-way-to-do-it>More than one way to do it</a></li><li><a href=#solutions>Solutions</a></li></ul></li><li><a href=#merge-sort>Merge sort</a><ul><li><a href=#a-higher-order-version>A higher-order version</a></li><li><a href=#composition>Composition</a></li></ul></li></ul></li></ul></nav></aside></header><article class=markdown><blockquote class="book-hint warning"><span>This course page was updated until March 2022 when I left Durham University.
For future updates, please visit
the <a href=https://comp2221.github.io/fp-website/>new version
of the course pages</a>.</span></blockquote><h1 id=more-list-manipulation>More list manipulation
<a class=anchor href=#more-list-manipulation>#</a></h1><p>We&rsquo;ll start off doing a bit more list manipulation, looking at some
list comprehensions and pattern matching. Then we&rsquo;ll implement <a href=https://en.wikipedia.org/wiki/Merge_sort>merge
sort</a>.</p><h2 id=list-comprehensions--pattern-matching>List comprehensions & pattern matching
<a class=anchor href=#list-comprehensions--pattern-matching>#</a></h2><p>For this section, the template code is <a href=https://teaching.wence.uk/comp2221/code/lists-exercise3.hs><code>code/lists-exercise3.hs</code></a>.</p><p>Let&rsquo;s first look at some pattern matching, and combination with guard
expressions.</p><blockquote class=exercise><h3>Exercise</h3><span>Write a function <code>compress :: Eq a => [a] -> [a]</code> that eliminates
consecutive duplicate elements of a list, but otherwise leaves the
order unchanged.</span></blockquote><p>Now some simple list comprehensions. A <a href=https://en.wikipedia.org/wiki/Pythagorean_triple>pythagorean
triple</a> is a tuple
$(x, y, z)$ of positive integers where $x^2 + y^2 = z^2$. For our
first go, we won&rsquo;t care about ordering, so we&rsquo;ll allow generation of
both $(3, 4, 5)$ and $(4, 3, 5)$ (for example).</p><blockquote class=exercise><h3>Exercise</h3><span><p>Using a list comprehension, define <code>pyths :: Int -> [(Int, Int, Int)]</code>
that generates all pythogorean truples with components less than or
equal to the specified integer.</p><p>For example</p><pre><code>Prelude&gt; pyths 5
[(3, 4, 5), (4, 3, 5)]
</code></pre><blockquote class="book-hint info"><span>Note that integer exponentiation in Haskell is written <code>x^y</code>.</span></blockquote></span></blockquote><blockquote class=exercise><h3>Exercise</h3><span><p>Now modify your answer to only produce unique triples (don&rsquo;t worry
about ordering), so for example</p><pre><code>Prelude&gt; pyths' 5
[(3, 4, 5)]
</code></pre><blockquote class="book-hint info"><span>Recall that when introducing variables in a list comprehension, later
generators can refer to the variables introduced by earlier ones.</span></blockquote></span></blockquote><blockquote class=question><h3>Question</h3><span><p>The power two is special here, indeed <a href=https://en.wikipedia.org/wiki/Fermat%27s_Last_Theorem>Fermat&rsquo;s Last
Theorem</a>,
proved by Andrew Wiles in 1994, states that the equation $x^n + y^n =
z^n$ has no solutions for positive integers $x, y, z, n$ when $n > 2$.</p><p>You could try and confirm this for $n = 3$ by checking that the list
generated by a comprehension with $x^3 + y^3 = z^3$ is empty.</p><p>Would you be able to use this to prove the theorem? If not, why not?</p></span></blockquote><h3 id=more-than-one-way-to-do-it>More than one way to do it
<a class=anchor href=#more-than-one-way-to-do-it>#</a></h3><p>Unlike Python for which the <a href=https://www.python.org/dev/peps/pep-0020/>zen of
python</a> says that</p><blockquote><p>There should be one &ndash; and preferably only one &ndash; obvious way to do
it.</p></blockquote><p>In Haskell there are often multiple different ways to do the same
thing, each of which may be more or less obvious depending on what
you&rsquo;re used to.</p><p>Let&rsquo;s look at this by definining a function to compute the scalar
product of two vectors (represented as lists) of numbers of length
$n$. Recall that the scalar (or dot)
<a href=https://en.wikipedia.org/wiki/Dot_product>product</a> is defined as</p><p>$$
a \cdot b = \sum_{i=1}^{N} a_i b_i
$$</p><blockquote class=exercise><h3>Exercise</h3><span><p>Define a function to compute the scalar product in three different
ways</p><ol><li>Using <code>sum</code> and a list comprehension</li><li>Using <code>sum</code>, <code>map</code>, and <code>zip</code>.</li><li>Using <code>sum</code> and <code>zipWith</code></li></ol><p>The template code has a few more explanatory comments.</p><p>You may assume that both vectors have the same length.</p></span></blockquote><blockquote class=question><h3>Question</h3><span>Which do you prefer, and why?</span></blockquote><h3 id=solutions>Solutions
<a class=anchor href=#solutions>#</a></h3><p>I&rsquo;ve added some <a href=https://teaching.wence.uk/comp2221/code/exercises/exercise3-solutions.hs>commented solutions</a> to these exercises. If you
have queries about them please ask in the practical sessions or else
<a href=https://teaching.wence.uk/comp2221/#discussion-forum>get in touch</a>.</p><h2 id=merge-sort>Merge sort
<a class=anchor href=#merge-sort>#</a></h2><p>Now we&rsquo;re going to implement sorting of lists using the <a href=https://en.wikipedia.org/wiki/Merge_sort>merge
sort</a> algorithm. Merge sort
is a divide-and-conquer algorithm that is built out of three parts.</p><ol><li>Dividing a list into two sublists that are to be sorted.</li><li>Sorting the sublists</li><li>Merging two sublists that are already sorted</li></ol><p>This has a very natural recursive definition and a succint Haskell
implementation.</p><p>We&rsquo;ll break this into parts. The template code for this exercise is in
<a href=https://teaching.wence.uk/comp2221/code/lists-mergesort.hs><code>code/lists-mergesort.hs</code></a></p><p>First, define a function</p><div class=highlight><pre style=color:#272822;background-color:#fafafa><code class=language-hs data-lang=hs><span style=color:#75af00>halve</span> <span style=color:#f92672>::</span> <span style=color:#111>[</span><span style=color:#111>a</span><span style=color:#111>]</span> <span style=color:#f92672>-&gt;</span> <span style=color:#111>([</span><span style=color:#111>a</span><span style=color:#111>],</span> <span style=color:#111>[</span><span style=color:#111>a</span><span style=color:#111>])</span>
</code></pre></div><p>which splits a list into two halves at its midpoint (for odd-length
lists the two sublists should have lengths that differ by at most
one). You might find <a href=https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-List.html#v:splitAt><code>splitAt :: Int -> [a] -> ([a], [a])</code></a>
helpful.</p><p>Next define a function</p><div class=highlight><pre style=color:#272822;background-color:#fafafa><code class=language-hs data-lang=hs><span style=color:#75af00>merge</span> <span style=color:#f92672>::</span> <span style=color:#00a8c8>Ord</span> <span style=color:#111>a</span> <span style=color:#f92672>=&gt;</span> <span style=color:#111>[</span><span style=color:#111>a</span><span style=color:#111>]</span> <span style=color:#f92672>-&gt;</span> <span style=color:#111>[</span><span style=color:#111>a</span><span style=color:#111>]</span> <span style=color:#f92672>-&gt;</span> <span style=color:#111>[</span><span style=color:#111>a</span><span style=color:#111>]</span>
</code></pre></div><p>which takes two (sorted) lists and merges them into one sorted list.
This is probably easiest to write recursively, think about the
possible cases.</p><p>Finally use your two helper functions to write</p><div class=highlight><pre style=color:#272822;background-color:#fafafa><code class=language-hs data-lang=hs><span style=color:#75af00>mergeSort</span> <span style=color:#f92672>::</span> <span style=color:#00a8c8>Ord</span> <span style=color:#111>a</span> <span style=color:#f92672>=&gt;</span> <span style=color:#111>[</span><span style=color:#111>a</span><span style=color:#111>]</span> <span style=color:#f92672>-&gt;</span> <span style=color:#111>[</span><span style=color:#111>a</span><span style=color:#111>]</span>
</code></pre></div><p>Again, the recursive definition is a natural one. There are base cases
for empty and singleton lists, while the recursive case should
implement the divide and conquer, splitting and merging sorted sublists.</p><h3 id=a-higher-order-version>A higher-order version
<a class=anchor href=#a-higher-order-version>#</a></h3><p>Notice how this implementation of <code>mergeSort</code> requires that the list
entries are
<a href=https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Ord.html#t:Ord><em>orderable</em></a>.
It is often useful to instead allow the caller to provide a comparison
function that orders elements.</p><p>Rework your code to implement</p><div class=highlight><pre style=color:#272822;background-color:#fafafa><code class=language-hs data-lang=hs><span style=color:#75af00>mergeSortWith</span> <span style=color:#f92672>::</span> <span style=color:#111>(</span><span style=color:#111>a</span> <span style=color:#f92672>-&gt;</span> <span style=color:#111>a</span> <span style=color:#f92672>-&gt;</span> <span style=color:#00a8c8>Ordering</span><span style=color:#111>)</span> <span style=color:#f92672>-&gt;</span> <span style=color:#111>[</span><span style=color:#111>a</span><span style=color:#111>]</span> <span style=color:#f92672>-&gt;</span> <span style=color:#111>[</span><span style=color:#111>a</span><span style=color:#111>]</span>
</code></pre></div><p>Where the
<a href=https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Ord.html#t:Ordering><code>Ordering</code></a>
type has three values <code>LT</code>, <code>EQ</code>, or <code>GT</code>.</p><p>You&rsquo;ll need to implement new <code>mergeWith</code> and <code>mergeSortWith</code> functions.
With <code>mergeSortWith</code> implemented, the implementation of <code>mergeSort</code> is
then just</p><div class=highlight><pre style=color:#272822;background-color:#fafafa><code class=language-hs data-lang=hs><span style=color:#75af00>mergeSort&#39;</span> <span style=color:#f92672>::</span> <span style=color:#00a8c8>Ord</span> <span style=color:#111>a</span> <span style=color:#f92672>=&gt;</span> <span style=color:#111>[</span><span style=color:#111>a</span><span style=color:#111>]</span> <span style=color:#f92672>-&gt;</span> <span style=color:#111>[</span><span style=color:#111>a</span><span style=color:#111>]</span>
<span style=color:#75af00>mergeSort&#39;</span> <span style=color:#f92672>=</span> <span style=color:#111>mergeSortWith</span> <span style=color:#111>compare</span>
</code></pre></div><p>Where we used the generic function
<a href=https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Ord.html#v:compare>compare</a>.</p><blockquote class=question><h3>Question</h3><span>Do you understand how the implementation of <code>mergeSort'</code> works using
currying and partial application?</span></blockquote><h3 id=composition>Composition
<a class=anchor href=#composition>#</a></h3><p>We can use this idea of higher-order functions and composition as
building blocks for a number of different ways of sorting objects.</p><p>To simplify spelling things, let&rsquo;s introduce a type-synonym for the
type of the comparison function</p><div class=highlight><pre style=color:#272822;background-color:#fafafa><code class=language-hs data-lang=hs><span style=color:#00a8c8>type</span> <span style=color:#00a8c8>Comparator</span> <span style=color:#111>a</span> <span style=color:#f92672>=</span> <span style=color:#111>a</span> <span style=color:#f92672>-&gt;</span> <span style=color:#111>a</span> <span style=color:#f92672>-&gt;</span> <span style=color:#00a8c8>Ordering</span>
</code></pre></div><p>We can now do various things, suppose that we want to sort lists in a
reverse order from the one given by the default ordering. We could do</p><div class=highlight><pre style=color:#272822;background-color:#fafafa><code class=language-hs data-lang=hs><span style=color:#75af00>sortReverse</span> <span style=color:#f92672>::</span> <span style=color:#00a8c8>Ord</span> <span style=color:#111>a</span> <span style=color:#f92672>=&gt;</span> <span style=color:#111>[</span><span style=color:#111>a</span><span style=color:#111>]</span> <span style=color:#f92672>-&gt;</span> <span style=color:#111>[</span><span style=color:#111>a</span><span style=color:#111>]</span>
<span style=color:#75af00>sortReverse</span> <span style=color:#f92672>=</span> <span style=color:#111>reverse</span> <span style=color:#f92672>.</span> <span style=color:#111>mergeSortWith</span> <span style=color:#111>compare</span>
</code></pre></div><p>But this unnecessarily traverses the list to reverse it at the end.</p><p>Better is to invert the comparison function. I provide an
<code>invertOrdering</code> function that reverses an ordering.</p><blockquote class=exercise><h3>Exercise</h3><span><p>Implement</p><div class=highlight><pre style=color:#272822;background-color:#fafafa><code class=language-hs data-lang=hs><span style=color:#75af00>invert</span> <span style=color:#f92672>::</span> <span style=color:#00a8c8>Comparator</span> <span style=color:#111>a</span> <span style=color:#f92672>-&gt;</span> <span style=color:#00a8c8>Comparator</span> <span style=color:#111>a</span>
</code></pre></div><p>Which takes a comparator and produces a new comparator that delivers
the reverse. We can then implement <code>sortReverse</code> without the extra
traversal</p><div class=highlight><pre style=color:#272822;background-color:#fafafa><code class=language-hs data-lang=hs><span style=color:#75af00>sortReverse</span> <span style=color:#f92672>::</span> <span style=color:#00a8c8>Ord</span> <span style=color:#111>a</span> <span style=color:#f92672>=&gt;</span> <span style=color:#111>[</span><span style=color:#111>a</span><span style=color:#111>]</span> <span style=color:#f92672>-&gt;</span> <span style=color:#111>[</span><span style=color:#111>a</span><span style=color:#111>]</span>
<span style=color:#75af00>sortReverse</span> <span style=color:#111>xs</span> <span style=color:#f92672>=</span> <span style=color:#111>mergeSortWith</span> <span style=color:#111>(</span><span style=color:#111>invert</span> <span style=color:#111>compare</span><span style=color:#111>)</span> <span style=color:#111>xs</span>
</code></pre></div><blockquote class="book-hint info"><span><p>The <code>invert</code> function <em>returns</em> a function, so we need
a way to introduce names for its arguments (they don&rsquo;t appear on the
left hand side of the definition).</p><p>The easiest way to do this is by using a lambda expression on the
right hand side. If you want to then see how write it in
<a href=https://wiki.haskell.org/Pointfree>pointfree</a> style, go to
<a href=http://pointfree.io>pointfree.io</a>.</p></span></blockquote></span></blockquote><p>Now let&rsquo;s look at slightly more involved comparator transformations.</p><p>Suppose we have a <code>Comparator a</code> and a way of turning <code>b</code>s into <code>a</code>s,
we can use this to deliver a <code>Comparator b</code>. We&rsquo;ll call this function
<code>on</code> for reasons which will become (hopefully) obvious.</p><div class=highlight><pre style=color:#272822;background-color:#fafafa><code class=language-hs data-lang=hs><span style=color:#75af00>on</span> <span style=color:#f92672>::</span> <span style=color:#00a8c8>Comparator</span> <span style=color:#111>a</span> <span style=color:#f92672>-&gt;</span> <span style=color:#111>(</span><span style=color:#111>b</span> <span style=color:#f92672>-&gt;</span> <span style=color:#111>a</span><span style=color:#111>)</span> <span style=color:#f92672>-&gt;</span> <span style=color:#00a8c8>Comparator</span> <span style=color:#111>b</span>
<span style=color:#75af00>on</span> <span style=color:#f92672>=</span> <span style=color:#111>undefined</span>
</code></pre></div><p>For example, suppose we want to compare tuples by their first element
using the builtin <code>compare</code> on that element.</p><p>Our comparison operation would be</p><div class=highlight><pre style=color:#272822;background-color:#fafafa><code class=language-hs data-lang=hs><span style=color:#75af00>on</span> <span style=color:#111>compare</span> <span style=color:#111>fst</span>
</code></pre></div><p>Now we can see why we called this function <code>on</code>, since when we write
it with infix notation</p><div class=highlight><pre style=color:#272822;background-color:#fafafa><code class=language-hs data-lang=hs><span style=color:#75af00>compare</span> <span style=color:#111>`</span><span style=color:#111>on</span><span style=color:#111>`</span> <span style=color:#111>fst</span>
</code></pre></div><p>We read this as &ldquo;Compare the elements on their first part&rdquo;. As an
example, if we run</p><pre><code>Prelude&gt; mergeSortWith (compare `on` fst`) [(7, &quot;a&quot;), (-1, &quot;b&quot;), (5, &quot;d&quot;)]
[(-1, &quot;b&quot;), (5, &quot;d&quot;), (7, &quot;a&quot;)]
</code></pre><blockquote class=exercise><h3>Exercise</h3><span><p>Implement <code>on</code>. Check that it produces the right answer.</p><blockquote class="book-hint info"><span><p>Like with <code>invert</code>, the <code>on</code> function <em>returns</em> a function, so we need
a way to introduce names for its arguments (they don&rsquo;t appear on the
left hand side of the definition).</p><p>The easiest way to do this is by using a lambda expression on the
right hand side. If you want to then see how write it in
<a href=https://wiki.haskell.org/Pointfree>pointfree</a> style, go to
<a href=http://pointfree.io>pointfree.io</a>.</p></span></blockquote><blockquote class="book-hint info"><span><p>If the transformation function you provide is the identity function
<code>id</code>, then you should get back the same thing as if you had not used
<code>on</code>. This is a useful sanity check.</p><p>That is</p><div class=highlight><pre style=color:#272822;background-color:#fafafa><code class=language-hs data-lang=hs><span style=color:#75af00>compare</span> <span style=color:#111>`</span><span style=color:#111>on</span><span style=color:#111>`</span> <span style=color:#111>id</span> <span style=color:#f92672>==</span> <span style=color:#111>compare</span>
</code></pre></div></span></blockquote></span></blockquote><blockquote class=exercise><h3>Exercise</h3><span><p>Finally, we&rsquo;ll compose these two extra functions. Write a function</p><div class=highlight><pre style=color:#272822;background-color:#fafafa><code class=language-hs data-lang=hs><span style=color:#75af00>sortReversedByLengthSnd</span> <span style=color:#f92672>::</span> <span style=color:#111>[(</span><span style=color:#111>a</span><span style=color:#111>,</span> <span style=color:#00a8c8>String</span><span style=color:#111>)]</span> <span style=color:#f92672>-&gt;</span> <span style=color:#111>[(</span><span style=color:#111>a</span><span style=color:#111>,</span> <span style=color:#00a8c8>String</span><span style=color:#111>)]</span>
</code></pre></div><p>That sorts a list of pairs of something and strings in reverse order
by the length of the string.</p><p>For example</p><pre><code>Prelude&gt; sortReversedByLengthSnd [(5, &quot;a&quot;), (2, &quot;foo&quot;), (3, &quot;four&quot;), (7, &quot;ab&quot;)]
[(3, &quot;four&quot;), (2, &quot;foo&quot;), (7, &quot;ab&quot;), (5, &quot;a&quot;)]
</code></pre><p>You should not write this comparison function by hand, but just
compose together functions which you already have.</p></span></blockquote><div class=markdown-inner><h2 id=solutions>Solutions</h2><p>I&rsquo;ve added some <a href=https://teaching.wence.uk/comp2221/code/exercises/mergesort-solutions.hs>commented solutions</a> to these exercises. If you
have queries about them please ask in the practical sessions or else
<a href=https://teaching.wence.uk/comp2221/#discussion-forum>get in touch</a>.</div></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/wenceorg/comp2221/commit/198deafeeeb2da156fc46b80a0adbfce2f39646c title="Last modified by Lawrence Mitchell | April 7, 2022" target=_blank rel=noopener><img src=/comp2221/svg/calendar.svg class=book-icon alt=Calendar>
<span>April 7, 2022</span></a></div><div><a class="flex align-center" href=https://github.com/wenceorg/comp2221/edit/main/site/content/exercises/exercise3.md target=_blank rel=noopener><img src=/comp2221/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div><div class="flex flex-wrap align-right"><p>© 2021&ndash; <a href=mailto:lawrence@wence.uk>Lawrence Mitchell</a> & <a href=https://www.dur.ac.uk/>Durham University</a>.</p><p><a rel=license href=http://creativecommons.org/licenses/by-sa/4.0/><img alt="Creative Commons License" style=border-width:0 src=/comp2221/cc-by-sa.svg></a>
This work is licensed under a <a rel=license href=http://creativecommons.org/licenses/by-sa/4.0/>Creative
Commons Attribution-ShareAlike 4.0 International License</a>.</p></div></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><nav id=TableOfContents><ul><li><a href=#more-list-manipulation>More list manipulation</a><ul><li><a href=#list-comprehensions--pattern-matching>List comprehensions & pattern matching</a><ul><li><a href=#more-than-one-way-to-do-it>More than one way to do it</a></li><li><a href=#solutions>Solutions</a></li></ul></li><li><a href=#merge-sort>Merge sort</a><ul><li><a href=#a-higher-order-version>A higher-order version</a></li><li><a href=#composition>Composition</a></li></ul></li></ul></li></ul></nav></aside></main></body></html>